복습과 정리를 통해서 어제 이해되지 않았던 모든 테스트 코드들에 대한 이해를 끝냈다! OwO

1. 서비스 테스트 클래스에 새로운 테스트 메소드 생성 :
   계좌가 없어서 findFirstByOrderByIdDesc가 Ontional.Empty()를 리턴하는 상황에서
   "100000000"이라는 계좌번호를 갖는 계좌를 생성하게 했는데, 이게 잘 동하는지 알아보기 위한 테스트!

이때 'findFirstByOrderByIdDesc가 Ontional.Empty()를 리턴하는 상황'을 설정하기 위해서 mockBean이 리턴하는 것을 수정한다.
> 이를 통해서 given이 주어진 상황에 맞게 bean들의 함수가 리턴하는 것을 바꿀 수 있다는 것을 알게 되었음
이 경우, Repository.save()의 인자에 전달되는 Account의 계좌번호가 "100000000"임을 검증해주면 됨

2. 이미 생성한 계좌의 수가 10개가 넘어서 더 이상 생성하지 못하게 에러를 띄우는게 잘 되는지 테스트 :
   일단 그 비지니스 로직이 구현되지 않은 상태이므로 구현해야 함!
   그런데 AccountUser의 Account 갯수를 어떻게 찾는담? > jpa 레퍼지토리에서 제공하는 함수로 간단히 가능 : findByAccountUser()

위 함수가 가능한 이유 : Account 도메인 안에 @ManyToOne 으로 AccountUser accountUser; 인스턴스를 선언했기 때문에 자동으로 두 도메인(테이블)이 연결된 것이다 - 아마 JPA의 문법인 것 같은데..! (두 테이블을 이어주는 어노테이션에 대해 더 공부를 해야 할 듯)

로직을 구현하고 나서 테스트는 `given(accountRepository.countByAccountUser(any())).willReturn(10);`처럼
사용자의 계좌 갯수가 무조건 10개가 되도록 상태를 설정하고, 에러코드가 우리가 의도한 것인지를 검증하면 됨
실제로 어떤 사용자에 대해서 그 사용자가 10개의 계좌를 만들고 에러를 발생하는지 확인하는 것은 어려우나, 모킹을 이용하면 간단히 상황설정을 할 수 있다는 것을 배울 수 있음

이때, 10개가 넘으면 에러를 던지는 메소드를 private으로 분리하고 craeteAccount안에서 호출하는게 깔끔한데, 어떤 기능을 할 때 validation이 너무 많으면 보기에도 복잡하므로 아무리 단순한 코드라고 하더라도 분리를 하는게 좋다고 말씀하심